#!/bin/bash
# SynOS Emergency Kill (Ctrl+K)
# Intelligently kills non-essential processes during memory emergencies

set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
DRY_RUN=false
TARGET=""
LOG_FILE="/var/log/synos/emergency-kill.log"
LOG_DIR="$(dirname "$LOG_FILE")"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --target)
            TARGET="$2"
            shift 2
            ;;
        --help|-h)
            echo "SynOS Emergency Kill - Intelligent Process Cleanup"
            echo ""
            echo "Usage: synos-emergency-kill [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --dry-run        Show what would be killed without actually killing"
            echo "  --target NAME    Kill only processes matching NAME"
            echo "  --help           Show this help message"
            echo ""
            echo "Protected processes (will NOT be killed):"
            echo "  - Kernel processes"
            echo "  - systemd, dbus, udev"
            echo "  - X11/Wayland display server"
            echo "  - MATE window manager"
            echo "  - Core AI services (synos-ai-daemon)"
            echo ""
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Create log directory if it doesn't exist
sudo mkdir -p "$LOG_DIR" 2>/dev/null || mkdir -p "$LOG_DIR"

# Log function
log_message() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $1" | tee -a "$LOG_FILE"
}

# Protected processes (will NOT be killed)
PROTECTED_PATTERNS=(
    "systemd"
    "dbus"
    "udev"
    "Xorg"
    "wayland"
    "mate-session"
    "mate-panel"
    "marco"  # MATE window manager
    "synos-ai-daemon"  # Core AI service
    "synos-consciousness-daemon"  # Keep consciousness alive
    "ssh"
    "sshd"
    "cron"
    "rsyslog"
    "init"
    "kernel"
    "kthread"
)

# High-priority targets (killed first)
HIGH_PRIORITY_TARGETS=(
    "chrome"
    "chromium"
    "firefox"
    "electron"
    "slack"
    "discord"
    "steam"
    "vlc"
    "gimp"
    "libreoffice"
    "virtualbox"
    "qemu"
    "docker"
)

# Medium-priority targets
MEDIUM_PRIORITY_TARGETS=(
    "code"  # VS Code
    "atom"
    "sublime"
    "gedit"
    "pluma"
    "nautilus"
    "caja"
    "burpsuite"
    "wireshark"
)

# Check if running as root for some operations
if [[ $EUID -eq 0 ]]; then
    IS_ROOT=true
else
    IS_ROOT=false
fi

# Get memory info before
MEMORY_BEFORE=$(free -m | awk 'NR==2{print $3}')

log_message "=== Emergency Kill Started ==="
log_message "Dry run: $DRY_RUN"
log_message "Target filter: ${TARGET:-all}"
log_message "Memory used before: ${MEMORY_BEFORE}MB"

# Function to check if process is protected
is_protected() {
    local process_name="$1"
    local pid="$2"

    # Don't kill PID 1 (init)
    if [[ "$pid" == "1" ]]; then
        return 0
    fi

    # Don't kill ourselves
    if [[ "$pid" == "$$" ]]; then
        return 0
    fi

    # Check against protected patterns
    for pattern in "${PROTECTED_PATTERNS[@]}"; do
        if [[ "$process_name" =~ $pattern ]]; then
            return 0
        fi
    done

    return 1
}

# Function to kill processes by priority
kill_by_priority() {
    local priority_name="$1"
    shift
    local targets=("$@")
    local killed_count=0

    echo -e "${CYAN}Checking $priority_name priority processes...${NC}"

    for target in "${targets[@]}"; do
        # Skip if target filter is set and doesn't match
        if [[ -n "$TARGET" && ! "$target" =~ $TARGET ]]; then
            continue
        fi

        # Find matching processes
        while read -r pid process_name; do
            if [[ -z "$pid" ]]; then
                continue
            fi

            # Skip if protected
            if is_protected "$process_name" "$pid"; then
                continue
            fi

            # Get memory usage
            mem_usage=$(ps -p "$pid" -o rss= 2>/dev/null || echo "0")
            mem_mb=$((mem_usage / 1024))

            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY RUN] Would kill: $process_name (PID: $pid, ${mem_mb}MB)${NC}"
                log_message "[DRY RUN] Would kill: $process_name (PID: $pid, ${mem_mb}MB)"
            else
                echo -e "${RED}Killing: $process_name (PID: $pid, ${mem_mb}MB)${NC}"
                log_message "Killing: $process_name (PID: $pid, ${mem_mb}MB)"

                # Try graceful kill first (SIGTERM)
                kill -15 "$pid" 2>/dev/null || true
                sleep 0.5

                # Force kill if still alive (SIGKILL)
                if ps -p "$pid" > /dev/null 2>&1; then
                    kill -9 "$pid" 2>/dev/null || true
                fi

                ((killed_count++))
            fi

        done < <(pgrep -x "$target" | while read -r pid; do
            process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "")
            echo "$pid $process_name"
        done)
    done

    if [[ $killed_count -gt 0 ]]; then
        echo -e "${GREEN}Killed $killed_count $priority_name priority processes${NC}"
    fi

    return $killed_count
}

# Show warning dialog
if [[ "$DRY_RUN" == "false" && -z "$TARGET" ]]; then
    if command -v zenity &> /dev/null; then
        zenity --question \
            --title="SynOS Emergency Kill" \
            --text="This will kill all non-essential processes to free memory.\n\nProtected:\n- System services\n- Window manager\n- Core AI services\n\nContinue?" \
            --width=400 2>/dev/null || exit 0
    fi
fi

# Kill high-priority targets first (browsers, heavy apps)
echo -e "\n${CYAN}=== Phase 1: High-Priority Targets ===${NC}"
kill_by_priority "high" "${HIGH_PRIORITY_TARGETS[@]}"

# Kill medium-priority targets
echo -e "\n${CYAN}=== Phase 2: Medium-Priority Targets ===${NC}"
kill_by_priority "medium" "${MEDIUM_PRIORITY_TARGETS[@]}"

# Kill other user processes (but not protected ones)
echo -e "\n${CYAN}=== Phase 3: Other User Processes ===${NC}"
killed_other=0

if [[ -z "$TARGET" ]]; then
    # Get all user processes
    while read -r pid process_name; do
        if [[ -z "$pid" ]]; then
            continue
        fi

        # Skip if protected
        if is_protected "$process_name" "$pid"; then
            continue
        fi

        # Get memory usage
        mem_usage=$(ps -p "$pid" -o rss= 2>/dev/null || echo "0")
        mem_mb=$((mem_usage / 1024))

        # Only kill if using more than 50MB
        if [[ $mem_mb -gt 50 ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY RUN] Would kill: $process_name (PID: $pid, ${mem_mb}MB)${NC}"
            else
                echo -e "${RED}Killing: $process_name (PID: $pid, ${mem_mb}MB)${NC}"
                log_message "Killing: $process_name (PID: $pid, ${mem_mb}MB)"
                kill -15 "$pid" 2>/dev/null || true
                sleep 0.2
                kill -9 "$pid" 2>/dev/null || true
                ((killed_other++))
            fi
        fi
    done < <(ps -u "$USER" -o pid=,comm= | grep -v "^$$")
fi

# Get memory info after
sleep 2
MEMORY_AFTER=$(free -m | awk 'NR==2{print $3}')
MEMORY_FREED=$((MEMORY_BEFORE - MEMORY_AFTER))

# Show summary
echo -e "\n${GREEN}=== Emergency Kill Complete ===${NC}"
echo -e "Memory before: ${MEMORY_BEFORE}MB"
echo -e "Memory after:  ${MEMORY_AFTER}MB"
echo -e "Memory freed:  ${GREEN}${MEMORY_FREED}MB${NC}"

log_message "Memory freed: ${MEMORY_FREED}MB"
log_message "=== Emergency Kill Complete ==="

# Show desktop notification
if [[ "$DRY_RUN" == "false" ]]; then
    notify-send "SynOS Emergency Kill" \
        "Memory freed: ${MEMORY_FREED}MB\nSee log: $LOG_FILE" \
        -i dialog-warning -t 5000 2>/dev/null || true
fi

# Ask Jarvis for suggestions
if [[ "$DRY_RUN" == "false" ]] && command -v synos-jarvis &> /dev/null; then
    echo -e "\n${CYAN}Asking Jarvis for recommendations...${NC}"
    synos-jarvis query "I just ran emergency kill and freed ${MEMORY_FREED}MB. What should I do next?" 2>/dev/null || true
fi

exit 0
