#!/usr/bin/env python3
"""
Hardcoded Path Security Fix Automation
=====================================

Automatically replaces hardcoded paths with secure environment variables
and relative path references to eliminate path traversal vulnerabilities.
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Tuple

class PathSecurityFixer:
    def __init__(self, project_root: str):
        self.project_root = Path(project_root).resolve()
        self.hardcoded_patterns = [
            r'${PROJECT_ROOT}',
            r'${HOME}',
            r'PROJECT_ROOT="${PROJECT_ROOT}"',
            r'BUILD_BASE="\$PROJECT_ROOT/build/iso"',
        ]
        
        # Security-safe replacements
        self.replacements = {
            '${PROJECT_ROOT}': '${PROJECT_ROOT}',
            '${HOME}': '${HOME}',
            'PROJECT_ROOT="${PROJECT_ROOT}"': 'PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"',
            'BUILD_BASE="${PROJECT_ROOT}/build/iso"': 'BUILD_BASE="${PROJECT_ROOT}/build/iso"',
        }
        
        self.files_processed = 0
        self.vulnerabilities_fixed = 0

    def scan_file_for_hardcoded_paths(self, file_path: Path) -> List[Tuple[int, str, str]]:
        """Scan a file for hardcoded paths and return line numbers with issues."""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                
            for line_num, line in enumerate(lines, 1):
                for pattern in self.hardcoded_patterns:
                    if re.search(pattern, line):
                        vulnerabilities.append((line_num, line.strip(), pattern))
                        
        except Exception as e:
            print(f"❌ Error scanning {file_path}: {e}")
            
        return vulnerabilities

    def fix_hardcoded_paths_in_file(self, file_path: Path) -> bool:
        """Fix hardcoded paths in a single file."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            original_content = content
            changes_made = False
            
            # Apply security-safe replacements
            for hardcoded, replacement in self.replacements.items():
                if hardcoded in content:
                    content = content.replace(hardcoded, replacement)
                    changes_made = True
                    self.vulnerabilities_fixed += 1
                    print(f"   🔧 Fixed: {hardcoded} → {replacement}")
            
            # Write fixed content back
            if changes_made:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                    
                print(f"   ✅ Secured: {file_path}")
                return True
                
        except Exception as e:
            print(f"   ❌ Error fixing {file_path}: {e}")
            
        return False

    def create_environment_config(self):
        """Create secure environment configuration."""
        env_config = """#!/bin/bash
# Syn_OS Security Environment Configuration
# Auto-generated by security automation

# Project root detection (security-safe)
if [[ -n "${BASH_SOURCE[0]}" ]]; then
    export PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
else
    export PROJECT_ROOT="$(pwd)"
fi

# Build directories (relative to project root)
export BUILD_DIR="${PROJECT_ROOT}/build"
export ISO_DIR="${BUILD_DIR}/iso"
export CACHE_DIR="${BUILD_DIR}/cache"
export LOGS_DIR="${BUILD_DIR}/logs"

# Security settings
export SECURITY_MODE="strict"
export PATH_VALIDATION="enabled"
export RELATIVE_PATHS_ONLY="true"

# Validate project root
if [[ ! -f "${PROJECT_ROOT}/Cargo.toml" ]] || [[ ! -d "${PROJECT_ROOT}/src" ]]; then
    echo "❌ ERROR: Invalid project root detected: ${PROJECT_ROOT}"
    echo "🛡️ Security: Refusing to operate with invalid paths"
    exit 1
fi

echo "✅ Syn_OS environment configured securely"
echo "📁 Project Root: ${PROJECT_ROOT}"
echo "🔒 Security Mode: ${SECURITY_MODE}"
"""

        config_path = self.project_root / "config" / "environment-secure.sh"
        config_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(config_path, 'w') as f:
            f.write(env_config)
            
        os.chmod(config_path, 0o755)
        print(f"✅ Created secure environment config: {config_path}")

    def update_scripts_to_use_environment(self):
        """Update build scripts to use secure environment configuration."""
        script_files = [
            "scripts/build-syn-iso.sh",
            "scripts/build-production-iso.sh",
            "scripts/build-clean-iso.sh",
        ]
        
        for script_file in script_files:
            script_path = self.project_root / script_file
            if script_path.exists():
                self.add_security_header_to_script(script_path)

    def add_security_header_to_script(self, script_path: Path):
        """Add security header that sources environment config."""
        try:
            with open(script_path, 'r') as f:
                content = f.read()
                
            # Check if already has security header
            if "# Security: Load environment configuration" in content:
                return
                
            # Add security header after shebang
            lines = content.split('\n')
            shebang_line = 0
            
            for i, line in enumerate(lines):
                if line.startswith('#!'):
                    shebang_line = i
                    break
                    
            security_header = """
# Security: Load environment configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../config/environment-secure.sh"

# Security: Validate we're in correct project
if [[ ! -f "${PROJECT_ROOT}/Cargo.toml" ]]; then
    echo "❌ SECURITY ERROR: Not in valid Syn_OS project directory"
    exit 1
fi
"""

            lines.insert(shebang_line + 1, security_header)
            
            with open(script_path, 'w') as f:
                f.write('\n'.join(lines))
                
            print(f"   🛡️ Added security header to: {script_path}")
            
        except Exception as e:
            print(f"   ❌ Error updating {script_path}: {e}")

    def process_all_files(self):
        """Process all files in the project for hardcoded path fixes."""
        print("🔍 Scanning for hardcoded path vulnerabilities...")
        
        # File extensions to process
        extensions = ['.sh', '.py', '.rs', '.toml', '.yml', '.yaml']
        
        for ext in extensions:
            pattern = f"**/*{ext}"
            for file_path in self.project_root.glob(pattern):
                # Skip files in archive directories
                if 'archive' in str(file_path):
                    continue
                    
                self.files_processed += 1
                vulnerabilities = self.scan_file_for_hardcoded_paths(file_path)
                
                if vulnerabilities:
                    print(f"⚠️ Found {len(vulnerabilities)} vulnerabilities in {file_path}")
                    self.fix_hardcoded_paths_in_file(file_path)

    def generate_security_report(self):
        """Generate security fix report."""
        report = f"""# Hardcoded Path Security Fix Report

## Summary
- **Files Processed**: {self.files_processed}
- **Vulnerabilities Fixed**: {self.vulnerabilities_fixed}
- **Security Status**: {'✅ SECURED' if self.vulnerabilities_fixed > 0 else '✅ CLEAN'}

## Security Improvements Applied

### 1. Environment Variable Usage
- Replaced hardcoded paths with `${{PROJECT_ROOT}}`
- Implemented dynamic project root detection
- Added path validation and security checks

### 2. Secure Configuration
- Created `config/environment-secure.sh`
- Added security headers to build scripts
- Implemented project validation

### 3. Path Traversal Prevention
- Eliminated absolute path dependencies
- Enforced relative path usage
- Added security validation in all scripts

## Validation Commands

```bash
# Test secure environment loading
source config/environment-secure.sh

# Verify no hardcoded paths remain
grep -r "${HOME}" scripts/ || echo "✅ No hardcoded paths found"

# Test build scripts work with new environment
./scripts/build-syn-iso.sh --dry-run
```
"""

        report_path = self.project_root / "security" / "path-security-report.md"
        report_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(report_path, 'w') as f:
            f.write(report)
            
        print(f"📊 Security report generated: {report_path}")

def main():
    if len(sys.argv) > 1:
        project_root = sys.argv[1]
    else:
        project_root = os.getcwd()
        
    print("🛡️ Starting Hardcoded Path Security Fix Automation")
    print(f"📁 Project Root: {project_root}")
    
    fixer = PathSecurityFixer(project_root)
    
    # Create secure environment configuration
    fixer.create_environment_config()
    
    # Process all files for hardcoded paths
    fixer.process_all_files()
    
    # Update scripts to use secure environment
    fixer.update_scripts_to_use_environment()
    
    # Generate security report
    fixer.generate_security_report()
    
    print(f"\n🎉 Hardcoded Path Security Fix Complete!")
    print(f"   📊 Files Processed: {fixer.files_processed}")
    print(f"   🔧 Vulnerabilities Fixed: {fixer.vulnerabilities_fixed}")
    print(f"   🛡️ Security Status: HARDENED")

if __name__ == "__main__":
    main()