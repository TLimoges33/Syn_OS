#!/usr/bin/env python3
"""
Real-time Vulnerability Assessment System for Syn_OS
Continuous vulnerability scanning with consciousness-driven prioritization
"""

import asyncio
import logging
import time
import json
import hashlib
import re
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import sqlite3
import uuid
from datetime import datetime, timedelta
import subprocess
import socket
import ipaddress

from src.consciousness_v2.consciousness_bus import ConsciousnessBus


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ScanType(Enum):
    """Types of vulnerability scans"""
    NETWORK_SCAN = "network_scan"
    WEB_APPLICATION = "web_application"
    SYSTEM_SCAN = "system_scan"
    DATABASE_SCAN = "database_scan"
    CONFIGURATION_AUDIT = "configuration_audit"
    COMPLIANCE_CHECK = "compliance_check"
    CONTINUOUS_MONITORING = "continuous_monitoring"


class ScanStatus(Enum):
    """Scan execution status"""
    QUEUED = "queued"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class Vulnerability:
    """Individual vulnerability finding"""
    vuln_id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    affected_asset: str
    asset_type: str
    port: Optional[int]
    service: Optional[str]
    proof_of_concept: Optional[str]
    remediation: str
    references: List[str]
    discovered_at: float
    last_seen: float
    verified: bool = False
    false_positive: bool = False
    risk_score: float = 0.0
    exploitability: float = 0.0
    business_impact: float = 0.0


@dataclass
class ScanJob:
    """Vulnerability scan job"""
    job_id: str
    scan_type: ScanType
    target: str
    parameters: Dict[str, Any]
    priority: int  # 1-10, 10 being highest
    status: ScanStatus
    created_at: float
    started_at: Optional[float] = None
    completed_at: Optional[float] = None
    progress: float = 0.0
    vulnerabilities_found: int = 0
    consciousness_level: float = 0.0
    automated: bool = True
    created_by: str = "system"


@dataclass
class AssetProfile:
    """Asset profile for vulnerability context"""
    asset_id: str
    hostname: str
    ip_address: str
    asset_type: str
    operating_system: Optional[str]
    services: List[Dict[str, Any]]
    criticality: str  # low, medium, high, critical
    business_function: str
    last_scanned: float
    vulnerability_count: int = 0
    risk_score: float = 0.0


class RealtimeVulnerabilityScanner:
    """
    Real-time vulnerability assessment system with consciousness-driven prioritization
    Continuously scans for vulnerabilities and adapts based on threat landscape
    """
    
    def __init__(self, consciousness_bus: ConsciousnessBus):
        """Initialize real-time vulnerability scanner"""
        self.consciousness_bus = consciousness_bus
        self.logger = logging.getLogger(__name__)
        
        # Configuration
        self.system_directory = "/var/lib/synos/vulnerability_scanner"
        self.database_file = f"{self.system_directory}/vulnerability_scanner.db"
        
        # Data stores
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.scan_jobs: Dict[str, ScanJob] = {}
        self.asset_profiles: Dict[str, AssetProfile] = {}
        
        # Scanning parameters
        self.max_concurrent_scans = 5
        self.scan_interval = 3600  # 1 hour for continuous scans
        self.consciousness_threshold = 0.6
        self.priority_threshold = 7
        
        # Vulnerability databases
        self.cve_database = {}
        self.exploit_database = {}
        
        # Network ranges to scan
        self.scan_ranges = ["192.168.1.0/24", "10.0.0.0/24"]
        
        # Initialize system
        asyncio.create_task(self._initialize_scanner())
    
    async def _initialize_scanner(self):
        """Initialize the vulnerability scanner"""
        try:
            self.logger.info("Initializing real-time vulnerability scanner...")
            
            # Create system directory
            import os
            os.makedirs(self.system_directory, exist_ok=True)
            
            # Initialize database
            await self._initialize_database()
            
            # Load existing data
            await self._load_scanner_data()
            
            # Initialize vulnerability databases
            await self._initialize_vulnerability_databases()
            
            # Start continuous scanning
            asyncio.create_task(self._start_continuous_scanning())
            
            # Start scan job processor
            asyncio.create_task(self._process_scan_jobs())
            
            self.logger.info("Real-time vulnerability scanner initialized")
            
        except Exception as e:
            self.logger.error(f"Error initializing vulnerability scanner: {e}")
    
    async def _initialize_database(self):
        """Initialize vulnerability scanner database"""
        try:
            conn = sqlite3.connect(self.database_file)
            cursor = conn.cursor()
            
            # Vulnerabilities table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    vuln_id TEXT PRIMARY KEY,
                    cve_id TEXT,
                    title TEXT NOT NULL,
                    description TEXT,
                    severity TEXT NOT NULL,
                    cvss_score REAL NOT NULL,
                    affected_asset TEXT NOT NULL,
                    asset_type TEXT NOT NULL,
                    port INTEGER,
                    service TEXT,
                    proof_of_concept TEXT,
                    remediation TEXT,
                    references TEXT,
                    discovered_at REAL NOT NULL,
                    last_seen REAL NOT NULL,
                    verified BOOLEAN NOT NULL DEFAULT 0,
                    false_positive BOOLEAN NOT NULL DEFAULT 0,
                    risk_score REAL NOT NULL DEFAULT 0.0,
                    exploitability REAL NOT NULL DEFAULT 0.0,
                    business_impact REAL NOT NULL DEFAULT 0.0
                )
            ''')
            
            # Scan jobs table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scan_jobs (
                    job_id TEXT PRIMARY KEY,
                    scan_type TEXT NOT NULL,
                    target TEXT NOT NULL,
                    parameters TEXT,
                    priority INTEGER NOT NULL,
                    status TEXT NOT NULL,
                    created_at REAL NOT NULL,
                    started_at REAL,
                    completed_at REAL,
                    progress REAL NOT NULL DEFAULT 0.0,
                    vulnerabilities_found INTEGER NOT NULL DEFAULT 0,
                    consciousness_level REAL NOT NULL DEFAULT 0.0,
                    automated BOOLEAN NOT NULL DEFAULT 1,
                    created_by TEXT NOT NULL DEFAULT 'system'
                )
            ''')
            
            # Asset profiles table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS asset_profiles (
                    asset_id TEXT PRIMARY KEY,
                    hostname TEXT NOT NULL,
                    ip_address TEXT NOT NULL,
                    asset_type TEXT NOT NULL,
                    operating_system TEXT,
                    services TEXT,
                    criticality TEXT NOT NULL,
                    business_function TEXT,
                    last_scanned REAL NOT NULL,
                    vulnerability_count INTEGER NOT NULL DEFAULT 0,
                    risk_score REAL NOT NULL DEFAULT 0.0
                )
            ''')
            
            # Create indexes
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_vulns_severity ON vulnerabilities (severity)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_vulns_asset ON vulnerabilities (affected_asset)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_jobs_status ON scan_jobs (status)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_jobs_priority ON scan_jobs (priority)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_assets_criticality ON asset_profiles (criticality)')
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Error initializing database: {e}")
            raise
    
    async def _load_scanner_data(self):
        """Load existing scanner data from database"""
        try:
            conn = sqlite3.connect(self.database_file)
            cursor = conn.cursor()
            
            # Load vulnerabilities
            cursor.execute('SELECT * FROM vulnerabilities')
            for row in cursor.fetchall():
                vuln = Vulnerability(
                    vuln_id=row[0],
                    cve_id=row[1],
                    title=row[2],
                    description=row[3],
                    severity=VulnerabilitySeverity(row[4]),
                    cvss_score=row[5],
                    affected_asset=row[6],
                    asset_type=row[7],
                    port=row[8],
                    service=row[9],
                    proof_of_concept=row[10],
                    remediation=row[11],
                    references=json.loads(row[12]) if row[12] else [],
                    discovered_at=row[13],
                    last_seen=row[14],
                    verified=bool(row[15]),
                    false_positive=bool(row[16]),
                    risk_score=row[17],
                    exploitability=row[18],
                    business_impact=row[19]
                )
                self.vulnerabilities[vuln.vuln_id] = vuln
            
            # Load active scan jobs
            cursor.execute('SELECT * FROM scan_jobs WHERE status IN (?, ?)', 
                         (ScanStatus.QUEUED.value, ScanStatus.RUNNING.value))
            for row in cursor.fetchall():
                job = ScanJob(
                    job_id=row[0],
                    scan_type=ScanType(row[1]),
                    target=row[2],
                    parameters=json.loads(row[3]) if row[3] else {},
                    priority=row[4],
                    status=ScanStatus(row[5]),
                    created_at=row[6],
                    started_at=row[7],
                    completed_at=row[8],
                    progress=row[9],
                    vulnerabilities_found=row[10],
                    consciousness_level=row[11],
                    automated=bool(row[12]),
                    created_by=row[13]
                )
                self.scan_jobs[job.job_id] = job
            
            # Load asset profiles
            cursor.execute('SELECT * FROM asset_profiles')
            for row in cursor.fetchall():
                asset = AssetProfile(
                    asset_id=row[0],
                    hostname=row[1],
                    ip_address=row[2],
                    asset_type=row[3],
                    operating_system=row[4],
                    services=json.loads(row[5]) if row[5] else [],
                    criticality=row[6],
                    business_function=row[7],
                    last_scanned=row[8],
                    vulnerability_count=row[9],
                    risk_score=row[10]
                )
                self.asset_profiles[asset.asset_id] = asset
            
            conn.close()
            
            self.logger.info(f"Loaded {len(self.vulnerabilities)} vulnerabilities, "
                           f"{len(self.scan_jobs)} active jobs, {len(self.asset_profiles)} assets")
            
        except Exception as e:
            self.logger.error(f"Error loading scanner data: {e}")
    
    async def _initialize_vulnerability_databases(self):
        """Initialize vulnerability and exploit databases"""
        try:
            # Sample CVE data for demonstration
            sample_cves = {
                "CVE-2023-1234": {
                    "title": "Remote Code Execution in Web Server",
                    "description": "Buffer overflow vulnerability allows remote code execution",
                    "cvss_score": 9.8,
                    "severity": VulnerabilitySeverity.CRITICAL,
                    "exploitability": 0.9,
                    "remediation": "Update to latest version or apply security patch"
                },
                "CVE-2023-5678": {
                    "title": "SQL Injection in Database Interface",
                    "description": "Improper input validation leads to SQL injection",
                    "cvss_score": 7.5,
                    "severity": VulnerabilitySeverity.HIGH,
                    "exploitability": 0.7,
                    "remediation": "Implement proper input validation and parameterized queries"
                }
            }
            
            self.cve_database.update(sample_cves)
            
            # Sample exploit data
            sample_exploits = {
                "CVE-2023-1234": {
                    "exploit_available": True,
                    "exploit_complexity": "low",
                    "public_exploit": True,
                    "metasploit_module": True
                }
            }
            
            self.exploit_database.update(sample_exploits)
            
            self.logger.info(f"Initialized vulnerability database with {len(self.cve_database)} CVEs")
            
        except Exception as e:
            self.logger.error(f"Error initializing vulnerability databases: {e}")
    
    async def _start_continuous_scanning(self):
        """Start continuous vulnerability scanning"""
        try:
            while True:
                await asyncio.sleep(self.scan_interval)
                
                # Check consciousness level
                consciousness_state = await self.consciousness_bus.get_consciousness_state()
                consciousness_level = consciousness_state.get('overall_consciousness_level', 0)
                
                if consciousness_level < self.consciousness_threshold:
                    self.logger.debug("Consciousness level too low for continuous scanning")
                    continue
                
                # Schedule scans based on asset criticality and last scan time
                await self._schedule_continuous_scans(consciousness_level)
                
        except Exception as e:
            self.logger.error(f"Error in continuous scanning: {e}")
    
    async def _schedule_continuous_scans(self, consciousness_level: float):
        """Schedule continuous scans based on asset profiles"""
        try:
            current_time = time.time()
            
            for asset in self.asset_profiles.values():
                # Calculate scan frequency based on criticality
                if asset.criticality == "critical":
                    scan_frequency = 3600  # 1 hour
                elif asset.criticality == "high":
                    scan_frequency = 7200  # 2 hours
                elif asset.criticality == "medium":
                    scan_frequency = 14400  # 4 hours
                else:
                    scan_frequency = 28800  # 8 hours
                
                # Check if scan is due
                if current_time - asset.last_scanned > scan_frequency:
                    # Create scan job
                    await self._create_scan_job({
                        "scan_type": ScanType.SYSTEM_SCAN,
                        "target": asset.ip_address,
                        "priority": self._get_asset_priority(asset),
                        "parameters": {
                            "asset_id": asset.asset_id,
                            "scan_depth": "standard"
                        }
                    })
            
        except Exception as e:
            self.logger.error(f"Error scheduling continuous scans: {e}")
    
    def _get_asset_priority(self, asset: AssetProfile) -> int:
        """Calculate scan priority for an asset"""
        base_priority = {
            "critical": 9,
            "high": 7,
            "medium": 5,
            "low": 3
        }.get(asset.criticality, 3)
        
        # Increase priority based on vulnerability count
        vuln_bonus = min(2, asset.vulnerability_count // 5)
        
        # Increase priority based on risk score
        risk_bonus = min(1, int(asset.risk_score / 5))
        
        return min(10, base_priority + vuln_bonus + risk_bonus)
    
    async def _process_scan_jobs(self):
        """Process queued scan jobs"""
        try:
            while True:
                await asyncio.sleep(30)  # Check every 30 seconds
                
                # Get queued jobs sorted by priority
                queued_jobs = [job for job in self.scan_jobs.values() 
                             if job.status == ScanStatus.QUEUED]
                queued_jobs.sort(key=lambda x: x.priority, reverse=True)
                
                # Count running jobs
                running_jobs = len([job for job in self.scan_jobs.values() 
                                  if job.status == ScanStatus.RUNNING])
                
                # Start new jobs if capacity available
                available_slots = self.max_concurrent_scans - running_jobs
                
                for job in queued_jobs[:available_slots]:
                    asyncio.create_task(self._execute_scan_job(job))
                
        except Exception as e:
            self.logger.error(f"Error processing scan jobs: {e}")
    
    async def _create_scan_job(self, job_data: Dict[str, Any]) -> str:
        """Create a new scan job"""
        try:
            job_id = str(uuid.uuid4())
            current_time = time.time()
            
            consciousness_state = await self.consciousness_bus.get_consciousness_state()
            consciousness_level = consciousness_state.get('overall_consciousness_level', 0)
            
            job = ScanJob(
                job_id=job_id,
                scan_type=job_data["scan_type"],
                target=job_data["target"],
                parameters=job_data.get("parameters", {}),
                priority=job_data.get("priority", 5),
                status=ScanStatus.QUEUED,
                created_at=current_time,
                consciousness_level=consciousness_level,
                automated=job_data.get("automated", True),
                created_by=job_data.get("created_by", "system")
            )
            
            # Store job
            await self._store_scan_job(job)
            self.scan_jobs[job_id] = job
            
            self.logger.info(f"Created scan job: {job.scan_type.value} for {job.target}")
            return job_id
            
        except Exception as e:
            self.logger.error(f"Error creating scan job: {e}")
            return ""
    
    async def _store_scan_job(self, job: ScanJob):
        """Store scan job in database"""
        try:
            conn = sqlite3.connect(self.database_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO scan_jobs 
                (job_id, scan_type, target, parameters, priority, status, created_at,
                 started_at, completed_at, progress, vulnerabilities_found, 
                 consciousness_level, automated, created_by)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                job.job_id, job.scan_type.value, job.target, json.dumps(job.parameters),
                job.priority, job.status.value, job.created_at, job.started_at,
                job.completed_at, job.progress, job.vulnerabilities_found,
                job.consciousness_level, job.automated, job.created_by
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Error storing scan job: {e}")
    
    async def _execute_scan_job(self, job: ScanJob):
        """Execute a vulnerability scan job"""
        try:
            self.logger.info(f"Executing scan job: {job.job_id} - {job.scan_type.value}")
            
            # Update job status
            job.status = ScanStatus.RUNNING
            job.started_at = time.time()
            await self._store_scan_job(job)
            
            # Execute scan based on type
            vulnerabilities = []
            
            if job.scan_type == ScanType.NETWORK_SCAN:
                vulnerabilities = await self._perform_network_scan(job)
            elif job.scan_type == ScanType.WEB_APPLICATION:
                vulnerabilities = await self._perform_web_scan(job)
            elif job.scan_type == ScanType.SYSTEM_SCAN:
                vulnerabilities = await self._perform_system_scan(job)
            elif job.scan_type == ScanType.CONFIGURATION_AUDIT:
                vulnerabilities = await self._perform_config_audit(job)
            
            # Process discovered vulnerabilities
            for vuln_data in vulnerabilities:
                vuln_id = await self._create_vulnerability(vuln_data, job)
                if vuln_id:
                    job.vulnerabilities_found += 1
            
            # Update job completion
            job.status = ScanStatus.COMPLETED
            job.completed_at = time.time()
            job.progress = 100.0
            await self._store_scan_job(job)
            
            # Update asset profile if applicable
            if "asset_id" in job.parameters:
                await self._update_asset_profile(job.parameters["asset_id"], job)
            
            self.logger.info(f"Scan job completed: {job.job_id} - Found {job.vulnerabilities_found} vulnerabilities")
            
        except Exception as e:
            job.status = ScanStatus.FAILED
            job.completed_at = time.time()
            await self._store_scan_job(job)
            self.logger.error(f"Error executing scan job {job.job_id}: {e}")
    
    async def _perform_network_scan(self, job: ScanJob) -> List[Dict[str, Any]]:
        """Perform network vulnerability scan"""
        vulnerabilities = []
        
        try:
            # Simulate network scanning
            target_ip = job.target
            
            # Check for common network vulnerabilities
            open_ports = await self._scan_ports(target_ip)
            
            for port, service in open_ports.items():
                # Check for known vulnerable services
                if service == "ssh" and port == 22:
                    vulnerabilities.append({
                        "title": "SSH Service Detected",
                        "description": f"SSH service running on port {port}",
                        "severity": VulnerabilitySeverity.INFO,
                        "cvss_score": 0.0,
                        "port": port,
                        "service": service,
                        "remediation": "Ensure SSH is properly configured with key-based authentication"
                    })
                
                elif service == "http" and port == 80:
                    vulnerabilities.append({
                        "title": "Unencrypted HTTP Service",
                        "description": f"HTTP service running on port {port} without encryption",
                        "severity": VulnerabilitySeverity.MEDIUM,
                        "cvss_score": 5.3,
                        "port": port,
                        "service": service,
                        "remediation": "Implement HTTPS encryption for web services"
                    })
            
            # Simulate additional network checks
            await asyncio.sleep(2)  # Simulate scan time
            
        except Exception as e:
            self.logger.error(f"Error in network scan: {e}")
        
        return vulnerabilities
    
    async def _scan_ports(self, target_ip: str) -> Dict[int, str]:
        """Scan for open ports on target"""
        open_ports = {}
        
        try:
            # Common ports to scan
            common_ports = {
                22: "ssh",
                23: "telnet", 
                25: "smtp",
                53: "dns",
                80: "http",
                110: "pop3",
                143: "imap",
                443: "https",
                993: "imaps",
                995: "pop3s"
            }
            
            for port, service in common_ports.items():
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((target_ip, port))
                    sock.close()
                    
                    if result == 0:
                        open_ports[port] = service
                        
                except Exception:
                    continue
            
        except Exception as e:
            self.logger.error(f"Error scanning ports: {e}")
        
        return open_ports
    
    async def _perform_web_scan(self, job: ScanJob) -> List[Dict[str, Any]]:
        """Perform web application vulnerability scan"""
        vulnerabilities = []
        
        try:
            # Simulate web application scanning
            vulnerabilities.extend([
                {
                    "title": "Missing Security Headers",
                    "description": "Web application missing important security headers",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "cvss_score": 4.3,
                    "service": "http",
                    "remediation": "Implement security headers: X-Frame-Options, X-XSS-Protection, etc."
                },
                {
                    "title": "Outdated Web Server Version",
                    "description": "Web server version may contain known vulnerabilities",
                    "severity": VulnerabilitySeverity.HIGH,
                    "cvss_score": 7.5,
                    "service": "http",
                    "remediation": "Update web server to latest stable version"
                }
            ])
            
            await asyncio.sleep(3)  # Simulate scan time
            
        except Exception as e:
            self.logger.error(f"Error in web scan: {e}")
        
        return vulnerabilities
    
    async def _perform_system_scan(self, job: ScanJob) -> List[Dict[str, Any]]:
        """Perform system vulnerability scan"""
        vulnerabilities = []
        
        try:
            # Simulate system scanning
            vulnerabilities.extend([
                {
                    "title": "Outdated Operating System",
                    "description": "Operating system requires security updates",
                    "severity": VulnerabilitySeverity.HIGH,
                    "cvss_score": 8.1,
                    "remediation": "Apply latest security patches and updates"
                },
                {
                    "title": "Weak Password Policy",
                    "description": "System password policy does not meet security standards",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "cvss_score": 5.9,
                    "remediation": "Implement strong password policy with complexity requirements"
                }
            ])
            
            await asyncio.sleep(4)  # Simulate scan time
            
        except Exception as e:
            self.logger.error(f"Error in system scan: {e}")
        
        return vulnerabilities
    
    async def _perform_config_audit(self, job: ScanJob) -> List[Dict[str, Any]]:
        """Perform configuration audit"""
        vulnerabilities = []
        
        try:
            # Simulate configuration auditing
            vulnerabilities.extend([
                {
                    "title": "Insecure Service Configuration",
                    "description": "Service configured with insecure default settings",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "cvss_score": 6.1,
                    "remediation": "Review and harden service configuration"
                }
            ])
            
            await asyncio.sleep(2)  # Simulate scan time
            
        except Exception as e:
            self.logger.error(f"Error in config audit: {e}")
        
        return vulnerabilities
    
    async def _create_vulnerability(self, vuln_data: Dict[str, Any], job: ScanJob) -> str:
        """Create a new vulnerability record"""
        try:
            vuln_id = str(uuid.uuid4())
            current_time = time.time()
            
            # Calculate risk score
            risk_score = self._calculate_risk_score(vuln_data, job)
            
            vulnerability = Vulnerability(
                vuln_id=vuln_id,
                cve_id=vuln_data.get("cve_id"),
                title=vuln_data["title"],
                description=vuln_data["description"],
                severity=vuln_data["severity"],
                cvss_score=vuln_data["cvss_score"],
                affected_asset=job.target,
                asset_type=job.parameters.get("asset_type", "unknown"),
                port=vuln_data.get("port"),
                service=vuln_data.get("service"),
                proof_of_concept=vuln_data.get("proof_of_concept"),
                remediation=vuln_data["remediation"],
                references=vuln_data.get("references", []),
                discovered_at=current_time,
                last_seen=current_time,
                risk_score=risk_score,
                exploitability=vuln_data.get("exploitability", 0.0),
                business_impact=vuln_data.get("business_impact", 0.0)
            )
            
            # Store vulnerability
            await self._store_vulnerability(vulnerability)
            self.vulnerabilities[vuln_id] = vulnerability
            
            self.logger.info(f"Created vulnerability: {vulnerability.title} - {vulnerability.severity.value}")
            return vuln_id
            
        except Exception as e:
            self.logger.error(f"Error creating vulnerability: {e}")
            return ""
    
    def _calculate_risk_score(self, vuln_data: Dict[str, Any], job: ScanJob) -> float:
        """Calculate risk score for vulnerability"""
        try:
            base_score = vuln_data["cvss_score"]
            
            # Asset criticality multiplier
            asset_id = job.parameters.get("asset_id")
            if asset_id and asset_id in self.asset_profiles:
                asset = self.asset_profiles[asset_id]
                criticality_multiplier = {
                    "critical": 1.5,
                    "high": 1.2,
                    "medium": 1.0,
                    "low": 0.8
                }.get(asset.criticality, 1.0)
            else:
                criticality_multiplier = 1.0
            
            # Exploitability factor
            exploitability = vuln_data.get("exploitability", 0.5)
            
            # Calculate final risk score
            risk_score = base_score * criticality_multiplier * (0.5 + exploitability * 0.5)
            
            return min(10.0, risk_score)
            
        except Exception as e:
            self.logger.error(f"Error calculating risk score: {e}")
            return vuln_data["cvss_score"]
    
    async def _store_vulnerability(self, vulnerability: Vulnerability):
        """Store vulnerability in database"""
        try:
            conn = sqlite3.connect(self.database_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerabilities
                (vuln_id, cve_id, title, description, severity, cvss_score, affected_asset,
                 asset_type, port, service, proof_of_concept, remediation, references,
                 discovered_at, last_seen, verified, false_positive, risk_score,
                 exploitability, business_impact)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vulnerability.vuln_id, vulnerability.cve_id, vulnerability.title,
                vulnerability.description, vulnerability.severity.value, vulnerability.cvss_score,
                vulnerability.affected_asset, vulnerability.asset_type, vulnerability.port,
                vulnerability.service, vulnerability.proof_of_concept, vulnerability.remediation,
                json.dumps(vulnerability.references), vulnerability.discovered_at,
                vulnerability.last_seen, vulnerability.verified, vulnerability.false_positive,
                vulnerability.risk_score, vulnerability.exploitability, vulnerability.business_impact
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Error storing vulnerability: {e}")
    
    async def _update_asset_profile(self, asset_id: str, job: ScanJob):
        """Update asset profile after scan completion"""
        try:
            current_time = time.time()
            
            if asset_id not in self.asset_profiles:
                # Create new asset profile
                asset = AssetProfile(
                    asset_id=asset_id,
                    hostname=job.target,
                    ip_address=job.target,
                    asset_type=job.parameters.get("asset_type", "server"),
                    operating_system=job.parameters.get("operating_system"),
                    services=[],
                    criticality=job.parameters.get("criticality", "medium"),
                    business_function=job.parameters.get("business_function", "unknown"),
                    last_scanned=current_time
                )
                self.asset_profiles[asset_id] = asset
            else:
                asset = self.asset_profiles[asset_id]
                asset.last_scanned = current_time
            
            # Update vulnerability count
            asset.vulnerability_count = len([v for v in self.vulnerabilities.values()
                                           if v.affected_asset == asset.ip_address])
            
            # Calculate risk score
            asset.risk_score = self._calculate_asset_risk_score(asset)
            
            # Store updated profile
            await self._store_asset_profile(asset)
            
        except Exception as e:
            self.logger.error(f"Error updating asset profile: {e}")
    
    async def _store_asset_profile(self, asset: AssetProfile):
        """Store asset profile in database"""
        try:
            conn = sqlite3.connect(self.database_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO asset_profiles
                (asset_id, hostname, ip_address, asset_type, operating_system, services,
                 criticality, business_function, last_scanned, vulnerability_count, risk_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                asset.asset_id, asset.hostname, asset.ip_address, asset.asset_type,
                asset.operating_system, json.dumps(asset.services), asset.criticality,
                asset.business_function, asset.last_scanned, asset.vulnerability_count,
                asset.risk_score
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Error storing asset profile: {e}")
    
    def _calculate_asset_risk_score(self, asset: AssetProfile) -> float:
        """Calculate overall risk score for an asset"""
        try:
            # Get vulnerabilities for this asset
            asset_vulns = [v for v in self.vulnerabilities.values()
                          if v.affected_asset == asset.ip_address and not v.false_positive]
            
            if not asset_vulns:
                return 0.0
            
            # Calculate weighted risk score
            total_risk = 0.0
            severity_weights = {
                VulnerabilitySeverity.CRITICAL: 10.0,
                VulnerabilitySeverity.HIGH: 7.5,
                VulnerabilitySeverity.MEDIUM: 5.0,
                VulnerabilitySeverity.LOW: 2.5,
                VulnerabilitySeverity.INFO: 0.5
            }
            
            for vuln in asset_vulns:
                weight = severity_weights.get(vuln.severity, 1.0)
                total_risk += vuln.cvss_score * weight
            
            # Normalize by number of vulnerabilities and apply criticality multiplier
            base_risk = total_risk / len(asset_vulns) if asset_vulns else 0
            
            criticality_multiplier = {
                "critical": 1.5,
                "high": 1.2,
                "medium": 1.0,
                "low": 0.8
            }.get(asset.criticality, 1.0)
            
            return min(10.0, base_risk * criticality_multiplier)
            
        except Exception as e:
            self.logger.error(f"Error calculating asset risk score: {e}")
            return 0.0
    
    # Public API methods
    
    async def create_manual_scan(self, scan_data: Dict[str, Any]) -> str:
        """Create a manual vulnerability scan"""
        try:
            # Validate scan data
            required_fields = ["scan_type", "target"]
            for field in required_fields:
                if field not in scan_data:
                    raise ValueError(f"Missing required field: {field}")
            
            # Convert scan_type string to enum if needed
            if isinstance(scan_data["scan_type"], str):
                scan_data["scan_type"] = ScanType(scan_data["scan_type"])
            
            # Set default priority for manual scans
            scan_data.setdefault("priority", 8)
            scan_data.setdefault("automated", False)
            scan_data.setdefault("created_by", "user")
            
            job_id = await self._create_scan_job(scan_data)
            
            if job_id:
                self.logger.info(f"Manual scan created: {job_id}")
                return job_id
            else:
                raise Exception("Failed to create scan job")
                
        except Exception as e:
            self.logger.error(f"Error creating manual scan: {e}")
            return ""
    
    async def get_vulnerabilities(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """Get vulnerabilities with optional filters"""
        try:
            if filters is None:
                filters = {}
                
            vulnerabilities = []
            
            for vuln in self.vulnerabilities.values():
                # Apply filters
                if filters.get("severity") and vuln.severity.value != filters["severity"]:
                    continue
                if filters.get("asset") and vuln.affected_asset != filters["asset"]:
                    continue
                if filters.get("exclude_false_positives", False) and vuln.false_positive:
                    continue
                if filters.get("verified_only", False) and not vuln.verified:
                    continue
                
                # Convert to dict
                vuln_dict = asdict(vuln)
                vuln_dict["severity"] = vuln.severity.value
                vulnerabilities.append(vuln_dict)
            
            # Sort by risk score descending
            vulnerabilities.sort(key=lambda x: x["risk_score"], reverse=True)
            
            # Apply limit if specified
            if filters.get("limit"):
                vulnerabilities = vulnerabilities[:filters["limit"]]
            
            return vulnerabilities
            
        except Exception as e:
            self.logger.error(f"Error getting vulnerabilities: {e}")
            return []
    
    async def get_scan_jobs(self, status_filter: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get scan jobs with optional status filter"""
        try:
            jobs = []
            
            for job in self.scan_jobs.values():
                if status_filter and job.status.value != status_filter:
                    continue
                
                job_dict = asdict(job)
                job_dict["scan_type"] = job.scan_type.value
                job_dict["status"] = job.status.value
                jobs.append(job_dict)
            
            # Sort by created_at descending
            jobs.sort(key=lambda x: x["created_at"], reverse=True)
            
            return jobs
            
        except Exception as e:
            self.logger.error(f"Error getting scan jobs: {e}")
            return []
    
    async def get_asset_profiles(self) -> List[Dict[str, Any]]:
        """Get all asset profiles"""
        try:
            assets = []
            
            for asset in self.asset_profiles.values():
                asset_dict = asdict(asset)
                assets.append(asset_dict)
            
            # Sort by risk score descending
            assets.sort(key=lambda x: x["risk_score"], reverse=True)
            
            return assets
            
        except Exception as e:
            self.logger.error(f"Error getting asset profiles: {e}")
            return []
    
    async def update_vulnerability(self, vuln_id: str, updates: Dict[str, Any]) -> bool:
        """Update vulnerability record"""
        try:
            if vuln_id not in self.vulnerabilities:
                return False
            
            vuln = self.vulnerabilities[vuln_id]
            
            # Apply updates
            if "verified" in updates:
                vuln.verified = updates["verified"]
            if "false_positive" in updates:
                vuln.false_positive = updates["false_positive"]
            if "remediation" in updates:
                vuln.remediation = updates["remediation"]
            
            # Update last seen
            vuln.last_seen = time.time()
            
            # Store updated vulnerability
            await self._store_vulnerability(vuln)
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error updating vulnerability: {e}")
            return False
    
    async def get_vulnerability_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        try:
            stats = {
                "total_vulnerabilities": len(self.vulnerabilities),
                "by_severity": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "info": 0
                },
                "verified_count": 0,
                "false_positive_count": 0,
                "active_scans": len([j for j in self.scan_jobs.values()
                                   if j.status == ScanStatus.RUNNING]),
                "queued_scans": len([j for j in self.scan_jobs.values()
                                   if j.status == ScanStatus.QUEUED]),
                "total_assets": len(self.asset_profiles),
                "high_risk_assets": len([a for a in self.asset_profiles.values()
                                       if a.risk_score >= 7.0])
            }
            
            for vuln in self.vulnerabilities.values():
                stats["by_severity"][vuln.severity.value] += 1
                if vuln.verified:
                    stats["verified_count"] += 1
                if vuln.false_positive:
                    stats["false_positive_count"] += 1
            
            return stats
            
        except Exception as e:
            self.logger.error(f"Error getting vulnerability statistics: {e}")
            return {}
    
    async def cancel_scan_job(self, job_id: str) -> bool:
        """Cancel a scan job"""
        try:
            if job_id not in self.scan_jobs:
                return False
            
            job = self.scan_jobs[job_id]
            
            if job.status in [ScanStatus.COMPLETED, ScanStatus.FAILED, ScanStatus.CANCELLED]:
                return False
            
            job.status = ScanStatus.CANCELLED
            job.completed_at = time.time()
            
            await self._store_scan_job(job)
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error cancelling scan job: {e}")
            return False
    
    async def health_check(self) -> Dict[str, Any]:
        """Get scanner health status"""
        try:
            consciousness_state = await self.consciousness_bus.get_consciousness_state()
            
            return {
                "status": "healthy",
                "consciousness_level": consciousness_state.get('overall_consciousness_level', 0),
                "active_scans": len([j for j in self.scan_jobs.values()
                                   if j.status == ScanStatus.RUNNING]),
                "queued_scans": len([j for j in self.scan_jobs.values()
                                   if j.status == ScanStatus.QUEUED]),
                "total_vulnerabilities": len(self.vulnerabilities),
                "database_connected": True,
                "last_continuous_scan": max([a.last_scanned for a in self.asset_profiles.values()],
                                          default=0)
            }
            
        except Exception as e:
            self.logger.error(f"Error in health check: {e}")
            return {"status": "unhealthy", "error": str(e)}
    
    async def shutdown(self):
        """Shutdown the vulnerability scanner"""
        try:
            self.logger.info("Shutting down vulnerability scanner...")
            
            # Cancel all running jobs
            for job in self.scan_jobs.values():
                if job.status == ScanStatus.RUNNING:
                    job.status = ScanStatus.CANCELLED
                    await self._store_scan_job(job)
            
            self.logger.info("Vulnerability scanner shutdown complete")
            
        except Exception as e:
            self.logger.error(f"Error during shutdown: {e}")


# Example usage and testing
async def main():
    """Example usage of the real-time vulnerability scanner"""
    from src.consciousness_v2.consciousness_bus import ConsciousnessBus
    
    # Initialize consciousness bus
    consciousness_bus = ConsciousnessBus()
    
    # Create scanner
    scanner = RealtimeVulnerabilityScanner(consciousness_bus)
    
    # Wait for initialization
    await asyncio.sleep(2)
    
    # Get health status
    health = await scanner.health_check()
    print(f"Scanner health: {health}")
    
    # Get statistics
    stats = await scanner.get_vulnerability_statistics()
    print(f"Vulnerability statistics: {stats}")
    
    # Create a manual scan
    scan_result = await scanner.create_manual_scan({
        "scan_type": "network_scan",
        "target": "192.168.1.1",
        "priority": 8,
        "parameters": {
            "scan_depth": "comprehensive"
        }
    })
    print(f"Manual scan created: {scan_result}")
    
    # Wait for scan to complete
    await asyncio.sleep(10)
    
    # Get scan jobs
    jobs = await scanner.get_scan_jobs()
    print(f"Scan jobs: {len(jobs)}")
    
    # Get vulnerabilities
    vulns = await scanner.get_vulnerabilities({"exclude_false_positives": True})
    print(f"Vulnerabilities found: {len(vulns)}")
    
    # Get asset profiles
    assets = await scanner.get_asset_profiles()
    print(f"Asset profiles: {len(assets)}")
    
    # Shutdown
    await scanner.shutdown()


if __name__ == "__main__":
    asyncio.run(main())