// Enhanced Security Panic Handler
// Auto-generated by security automation

use core::panic::PanicInfo;
use x86_64::instructions::interrupts;

#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    // CRITICAL: Disable interrupts immediately for security
    interrupts::disable();
    
    // Security: Clear sensitive registers
    unsafe {
        core::arch::asm!(
            "xor rax, rax",
            "xor rbx, rbx", 
            "xor rcx, rcx",
            "xor rdx, rdx",
            options(nostack, preserves_flags)
        );
    }
    
    // Forensic data collection
    let panic_info = collect_panic_forensics(info);
    
    // Security logging
    security_log_panic(&panic_info);
    
    // Display panic information
    println!("üö® KERNEL SECURITY PANIC: {}", info);
    
    if let Some(location) = info.location() {
        println!(
            "üìç Location: {}:{}:{}",
            location.file(),
            location.line(),
            location.column()
        );
    }
    
    // Memory corruption detection
    detect_memory_corruption();
    
    // Stack corruption check
    check_stack_integrity();
    
    // Security: Wipe stack before halt
    wipe_stack_on_panic();
    
    println!("üîí Security: System halted safely");
    
    // Secure halt loop
    loop {
        x86_64::instructions::hlt();
    }
}

struct PanicForensics {
    timestamp: u64,
    location: Option<(&'static str, u32, u32)>,
    stack_pointer: usize,
    instruction_pointer: usize,
    memory_corruption_detected: bool,
    stack_canary_intact: bool,
}

fn collect_panic_forensics(info: &PanicInfo) -> PanicForensics {
    let mut forensics = PanicForensics {
        timestamp: crate::time::get_timestamp(),
        location: info.location().map(|loc| (loc.file(), loc.line(), loc.column())),
        stack_pointer: 0,
        instruction_pointer: 0,
        memory_corruption_detected: false,
        stack_canary_intact: true,
    };
    
    // Collect register information safely
    unsafe {
        core::arch::asm!(
            "mov {}, rsp",
            "mov {}, [rsp + 8]", // Return address
            out(reg) forensics.stack_pointer,
            out(reg) forensics.instruction_pointer,
            options(nomem, nostack, preserves_flags)
        );
    }
    
    forensics
}

fn security_log_panic(forensics: &PanicForensics) {
    // Security: Log to secure panic buffer
    // This would write to a protected memory region
    println!("üîê Security: Panic logged at timestamp {}", forensics.timestamp);
}

fn detect_memory_corruption() -> bool {
    // Implement basic memory corruption detection
    // Check heap metadata integrity
    if let Some(heap_status) = crate::memory::get_heap_status() {
        if !heap_status.metadata_intact {
            println!("‚ö†Ô∏è  SECURITY: Heap corruption detected");
            return true;
        }
    }
    
    // Check stack canaries
    if !check_stack_canaries() {
        println!("‚ö†Ô∏è  SECURITY: Stack canary corruption detected");
        return true;
    }
    
    false
}

fn check_stack_integrity() -> bool {
    // Basic stack integrity check
    let current_sp: usize;
    unsafe {
        core::arch::asm!("mov {}, rsp", out(reg) current_sp, options(nomem, nostack));
    }
    
    // Validate stack pointer is within expected range
    let stack_base = crate::memory::get_kernel_stack_base();
    let stack_size = crate::memory::get_kernel_stack_size();
    
    if current_sp < stack_base || current_sp > (stack_base + stack_size) {
        println!("‚ö†Ô∏è  SECURITY: Stack pointer corruption detected");
        return false;
    }
    
    true
}

fn check_stack_canaries() -> bool {
    // Check stack canaries are intact
    // This would verify canary values placed during function entry
    true // Placeholder - would implement actual canary checking
}

fn wipe_stack_on_panic() {
    // Security: Zero out sensitive stack data before halt
    unsafe {
        let stack_start = crate::memory::get_kernel_stack_base();
        let stack_size = 4096; // Use safer smaller size
        
        core::ptr::write_bytes(stack_start as *mut u8, 0, stack_size);
    }
}